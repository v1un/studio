
'use server';
/**
 * @fileOverview A Genkit flow for dynamically generating detailed main quests for a given chapter outline.
 * This flow is triggered when a chapter is completed and the next chapter exists only as an outline.
 * It uses the series plot summary and overall story context to create canonical quests.
 *
 * - fleshOutChapterQuests - Function to generate detailed quests for an outlined chapter.
 * - FleshOutChapterQuestsInput - Input type for the flow.
 * - FleshOutChapterQuestsOutput - Output type for the flow.
 */

import { ai, STANDARD_MODEL_NAME, PREMIUM_MODEL_NAME } from '@/ai/genkit';
import { z } from 'zod';
import type { Quest as QuestType, Chapter as ChapterType, Item as ItemType, FleshOutChapterQuestsInput as IFleshOutChapterQuestsInput, FleshOutChapterQuestsOutput as IFleshOutChapterQuestsOutput } from '@/types/story';
import { EquipSlotEnumInternal } from '@/types/zod-schemas';
import { lookupLoreTool } from '@/ai/tools/lore-tool';

// --- Schemas for AI communication (Subset, focused on Quest generation) ---
const ItemSchemaInternal = z.object({
  id: z.string().describe("A unique identifier for the item, e.g., 'item_reward_key_001'. Make it unique within the current rewards."),
  name: z.string().describe("The name of the item."),
  description: z.string().describe("A brief description of the item."),
  equipSlot: EquipSlotEnumInternal.optional().describe("If equippable gear, specify slot. OMIT if not (e.g. potion, key)."),
  isConsumable: z.boolean().optional(),
  effectDescription: z.string().optional(),
  isQuestItem: z.boolean().optional(),
  relevantQuestId: z.string().optional(),
  basePrice: z.number().optional().describe("Base value. MUST BE a number if provided."),
});

const QuestObjectiveSchemaInternal = z.object({
  description: z.string().describe("A clear description of this specific objective for the quest."),
  isCompleted: z.literal(false).describe("Must be false for new objectives."),
});

const QuestRewardsSchemaInternal = z.object({
  experiencePoints: z.number().optional().describe("XP awarded. MUST BE a number if provided."),
  items: z.array(ItemSchemaInternal).optional().describe("Items awarded. Each must have unique ID, name, description, 'basePrice' (number), and optional 'equipSlot' (omit if not equippable)."),
  currency: z.number().optional().describe("Currency awarded. MUST BE a number if provided."),
}).describe("Potential rewards. Defined at quest creation.");

const QuestSchemaInternal = z.object({
  id: z.string().describe("A unique identifier for the quest, e.g., 'quest_main_chapter2_001'. Must be unique among all quests being generated for this chapter."),
  title: z.string().optional().describe("A short, engaging title for the quest, fitting the chapter and series."),
  description: z.string().describe("A clear description of the quest's overall objective, fitting the series and chapter context."),
  type: z.literal('main').describe("All quests generated by this flow MUST be of type 'main'."),
  status: z.literal('active').describe("All quests generated by this flow MUST have status 'active'."),
  chapterId: z.string().describe("The ID of the chapter this quest belongs to (must match the input chapterToFleshOut.id)."),
  orderInChapter: z.number().optional().describe("Suggested sequence within the chapter (e.g., 1, 2, 3)."),
  category: z.string().optional().describe("Optional category (e.g., 'Investigation', 'Confrontation')."),
  objectives: z.array(QuestObjectiveSchemaInternal).optional().describe("1-3 specific sub-objectives. 'isCompleted' MUST be false."),
  rewards: QuestRewardsSchemaInternal.optional(),
});

// --- Input and Output Schemas for the Flow ---
const ChapterSchemaForInput = z.object({
    id: z.string(),
    title: z.string(),
    description: z.string(),
    order: z.number(),
    mainQuestIds: z.array(z.string()).optional(), // Should be empty or undefined for an outlined chapter
    isCompleted: z.literal(false),
    unlockCondition: z.string().optional(),
});

const FleshOutChapterQuestsInputSchema = z.object({
  chapterToFleshOut: ChapterSchemaForInput.describe("The outlined chapter object that needs its main quests generated."),
  seriesName: z.string().describe("The name of the series for context."),
  seriesPlotSummary: z.string().describe("A summary of the series' overall plot points to guide canonical quest generation."),
  overallStorySummarySoFar: z.string().describe("A summary of what has happened in the game so far, including events of the PREVIOUS chapter. This is crucial for narrative continuity."),
  characterContext: z.object({
      name: z.string(),
      class: z.string(),
      level: z.number(),
  }).describe("Minimal information about the player character for context."),
  usePremiumAI: z.boolean().optional().describe("Whether to use the premium AI model."),
});
export type FleshOutChapterQuestsInput = z.infer<typeof FleshOutChapterQuestsInputSchema>;

const FleshOutChapterQuestsOutputSchema = z.object({
  fleshedOutQuests: z.array(QuestSchemaInternal).describe("An array of 2-3 detailed main quests for the specified chapter, consistent with the series plot and chapter theme. Each quest must have a unique ID, title, description, type: 'main', status: 'active', the correct chapterId, orderInChapter, optional objectives, and rewards (with numeric prices/currency)."),
});
export type FleshOutChapterQuestsOutput = z.infer<typeof FleshOutChapterQuestsOutputSchema>;


export async function fleshOutChapterQuests(input: IFleshOutChapterQuestsInput): Promise<IFleshOutChapterQuestsOutput> {
  return fleshOutChapterQuestsFlow(input as FleshOutChapterQuestsInput); // Cast to Zod inferred type
}

const fleshOutChapterQuestsFlow = ai.defineFlow(
  {
    name: 'fleshOutChapterQuestsFlow',
    inputSchema: FleshOutChapterQuestsInputSchema,
    outputSchema: FleshOutChapterQuestsOutputSchema,
  },
  async (input) => {
    const flowStartTime = Date.now();
    console.log(`[${new Date(flowStartTime).toISOString()}] fleshOutChapterQuestsFlow: START for Chapter: "${input.chapterToFleshOut.title}" in Series: ${input.seriesName}, Premium: ${input.usePremiumAI}`);

    const modelName = input.usePremiumAI ? PREMIUM_MODEL_NAME : STANDARD_MODEL_NAME;
    const modelConfig = { maxOutputTokens: 4000 };

    const prompt = ai.definePrompt({
      name: 'fleshOutChapterQuestsPrompt',
      model: modelName,
      input: { schema: FleshOutChapterQuestsInputSchema },
      output: { schema: FleshOutChapterQuestsOutputSchema },
      tools: [lookupLoreTool],
      config: modelConfig,
      prompt: `IMPORTANT_INSTRUCTION: Your entire response MUST be a single, valid JSON object conforming to the 'FleshOutChapterQuestsOutputSchema'. Do not include any explanatory text, markdown formatting, or anything outside of the JSON structure.

You are a master storyteller crafting the main quests for a chapter in an interactive game set in the series: "{{seriesName}}".
The player character is {{characterContext.name}}, a level {{characterContext.level}} {{characterContext.class}}.

The specific chapter to flesh out is (ID: {{chapterToFleshOut.id}}):
- Chapter Title: {{chapterToFleshOut.title}}
- Chapter Description: {{chapterToFleshOut.description}}
- Chapter Order: {{chapterToFleshOut.order}}

Key Context for Quest Generation:
1.  **Series Canonical Plot Points (Primary Guide):**
    {{{seriesPlotSummary}}}
2.  **Overall Story Summary So Far (Crucial for Continuity):** This summary includes events from previous chapters. Ensure the new quests logically follow from these past events and create a smooth narrative transition.
    {{{overallStorySummarySoFar}}}

Your Task:
Generate an array of 2-3 'fleshedOutQuests' for the chapter titled "{{chapterToFleshOut.title}}".
- Each quest MUST be of \`type: "main"\` and \`status: "active"\`.
- Each quest's \`chapterId\` MUST be "{{chapterToFleshOut.id}}".
- Assign sequential \`orderInChapter\` numbers (e.g., 1, 2, 3).
- Quests MUST align with the \`seriesPlotSummary\` and the theme of \`{{chapterToFleshOut.title}}\`. They must also logically connect to the events described in \`overallStorySummarySoFar\`. Use the \`lookupLoreTool\` if needed for canonical accuracy on names, locations, specific items, or series-specific terms.
- Each quest MUST have a unique \`id\` (e.g., quest_main_{{chapterToFleshOut.id}}_001), an optional \`title\`, a detailed \`description\`, and 1-2 \`objectives\` (with \`isCompleted: false\`).
- **Crucially, include meaningful 'rewards' for these main quests** (experiencePoints (number), currency (number), and/or items (each with unique 'id', 'name', 'description', 'basePrice' (number), and optional 'equipSlot' - OMIT for non-equippable items)).
- Ensure all numeric fields (prices, XP, currency, etc.) are actual numbers.

Output ONLY the JSON object adhering to 'FleshOutChapterQuestsOutputSchema'. Example: \`{"fleshedOutQuests": [{"id": "...", "title": "...", ...}]}\`
Ensure all field names and values in your JSON response strictly match the types and requirements described in the FleshOutChapterQuestsOutputSchema definition.`,
    });

    let promptCallTime = Date.now();
    console.log(`[${new Date(promptCallTime).toISOString()}] fleshOutChapterQuestsFlow: Calling fleshOutChapterQuestsPrompt.`);
    const { output } = await prompt(input);
    console.log(`[${new Date().toISOString()}] fleshOutChapterQuestsFlow: fleshOutChapterQuestsPrompt call completed in ${Date.now() - promptCallTime}ms.`);

    if (!output || !output.fleshedOutQuests) {
      console.error("fleshOutChapterQuestsFlow: AI failed to return fleshedOutQuests.", output);
      throw new Error('AI failed to generate quests for the chapter.');
    }
    
    // Basic validation and default setting
    const validatedQuests = output.fleshedOutQuests.map((q, index) => ({
        ...q,
        id: q.id || `fleshed_quest_${input.chapterToFleshOut.id}_${Date.now()}_${index}`,
        type: 'main' as QuestType['type'], // Ensure type is main
        status: 'active' as QuestType['status'], // Ensure status is active
        chapterId: input.chapterToFleshOut.id, // Ensure correct chapterId
        orderInChapter: q.orderInChapter ?? (index + 1),
        objectives: q.objectives?.map(obj => ({...obj, isCompleted: false})) || [],
        rewards: q.rewards ? {
            experiencePoints: q.rewards.experiencePoints,
            currency: q.rewards.currency,
            items: q.rewards.items?.map((item, i) => ({
                ...item,
                id: item.id || `reward_item_${q.id}_${Date.now()}_${i}`,
                basePrice: item.basePrice ?? 0,
            } as ItemType)) || []
        } : undefined,
    }));


    console.log(`[${new Date().toISOString()}] fleshOutChapterQuestsFlow: END. Total time: ${Date.now() - flowStartTime}ms. Generated ${validatedQuests.length} quests.`);
    return { fleshedOutQuests: validatedQuests };
  }
);


